README.template

## Project Number/Title 

* Authors: Your Name, and your group members’ names
* Group name: Your Group Name

## Overview - James

This program uses C to implement a recursive sorting algorithm using parallelism and pthreads. 
This algorithm is divided up to a specified cutoff level, where the array is divided and sorted in parallel accross multiple threads.
the sorted segments are then merged to produce a fully sorted array. the main aim of this project is to increase the performance of a standard sorting algorithm through the use of multi-core processors.

## Manifest - James

mergesort.h | Declares functions, constants, and data structures. these are used for thread creation and mergesort.

mergesort.c | This file contains the core implementation, including thread management, recursive sort functions and merging routes. 


test-mergesort.c | This file is used for testing the merge sort function. it does this by generating input arrays, sorting, measuring execution time, and verifying correctness.

Makefile | Automates compilation and linking of source files into the executable test-mergesort.


## Building the project - Rhett

To build project us command sequence in terminal :
$ make 
$ ./test-mergesort <input size> <cutoff level> <seed>
Example :
$ make 
$ ./test-mergesort 100000000 8 1234

## Features and usage - Rhett

Features
Parallel mergesort with pthreads. Work is split recursively, threads are spawned until level == cutoff, then it switches to serial mergesort.
Thread-safe task args. Each thread receives a small struct argument { left, right, level } describing its subarray slice.
Efficient merging. Each merge writes into a shared auxiliary buffer B then memcpy’s the merged run back into A.
Deterministic input generation. A seeded RNG fills the array so experiments are repeatable.
Correctness checks & timing. Verifies non-decreasing order and reports wall-clock time in milliseconds/seconds.

Usage
Input creation: A and temp buffer B are allocated for n elements; A is filled using a seeded RNG.
Parallel sort entry: The root task is built with buildArgs(0, n-1, 0) and passed to parallel_mergesort.
Task splitting: If level < cutoff, two child threads sort [left..mid] and [mid+1..right], then the parent merges. Past the cutoff, it uses single-threaded my_mergesort.
Merge: Merge compares elements from the left and right runs into B and copies back into A.
Validation & report: The array is checked; on success, elapsed time is printed. 

## Testing - James

In the test file the function printSegmentSizes() was created to mimic the mergesort segmentation. this can be then used to visually verify recursion.
Then in the mergesort file (now commented out) thread verification methods were implemented. Note the introduction of a sorted check pre merging.
notably: creation verification and information, merge verification.

from this a generated output such as:
./test-mergesort 40 4 1234
Level 0: creating threads for array segment [0..39]
Thread 140173648865088: Level 0, creating thread for segment [0..39]
Level 1: creating threads for array segment [0..19]
Thread 140173648860864: Level 1, creating thread for segment [0..19]
Level 1: creating threads for array segment [20..39]
Thread 140173640468160: Level 1, creating thread for segment [20..39]
Segment [0..19] verified sorted by thread 140173648860864.
Segment [20..39] verified sorted by thread 140173640468160.
Segment [0..39] verified sorted by thread 140173648865088.
Sorting 40 elements took 0.00 seconds.

Here we verify the parrallellism of the mergesort.
verification of the actual mergesort algorithm is done by a simple call of the check_if_sorted(int A[], int n) function iterating through the array to confirm sort.

to verify the program, edge cases were ran:
Minimal input size: ./test-mergesort 2 0 1234
empty array/ too small: ./test-mergesort 1 0 1234
Test with all elements equal: for (i = 0; i < n; i++) A[i] = 42;
Test with already sorted: (i = 0; i < n; i++) A[i] = i; i.e. best case
Test with reverse sorted array: for (i = 0; i < n; i++) A[i] = n - i; i.e. worst case

using this we were able to verify that not only did the code work but it optimised complexity. interestgly to note if pre sorted, thread allocation is actually slower.

## Known Bugs - Caleb

List known bugs that you weren't able to fix (or ran out of time to fix).

## Reflection and Self Assessment - Caleb

Discuss the issues you encountered during development and testing. What
problems did you have? What did you have to research and learn on your own?
What kinds of errors did you get? How did you fix them?

What parts of the project did you find challenging? Is there anything that
finally "clicked" for you in the process of working on this project? How well
did the development and testing process go for you?

## Sources Used - Caleb

If you used any sources outside of the textbook, you should list them here. 
If you looked something up on stackoverflow.com or you use help from AI, and 
fail to cite it in this section, it will be considered plagiarism and dealt 
with accordingly. So be safe CITE!
